(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`Atlas`", {"GlobalVariables`", "RigidBodyDynamics`", "BipedalLocomotion`", "BipedalLocomotion`Model`", "HybridDynamics`"}]

Atlas::usage = "";
AtlasP::usage = "";
AtlasSurface::usage = "";

AtlasMeshOptions::usage = "";

Begin["`Private`"]


(* ::Input::Initialization:: *)
g = {0, 0, 9.81};

n\[Mu] = 2;

(* switching times *)
dt = {0, -2, -1};

atlas = {};
poi = {};
feet = {{"l.leg.akx", "r.leg.akx"}, {z3, z3}}\[Transpose];


(* ::Input::Initialization:: *)
(* pre-impact stance x[0-]/c- *)
stsw[s_] := If[StringMatchQ[s, "left"|"l"], {"l", "r"}, {"r", "l"}];


(* ::Input::Initialization:: *)
q0[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];

(* control variables, keep locked, e.g., at zero degrees *)
(t  <> ".leg.kn")
];

q3[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];
(* control variables *)
("neck")|("leg"~~__~~("x"|"z"))|("leg.aky")|(w  <>".arm.shy")|"wrx"
];

brm[s_] := {Automatic, "p"|"rx"|"rz"};

qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
(w <> ".leg.kn")|("neck")|("leg"~~__~~("x"|"z"))|("leg.aky")|"wrx"|(t  <>".arm.shy")
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
("neck")|("leg"~~__~~("x"|"z"))|("leg.aky")|"wrx"|(t  <>".arm.shy")
];

xrm[s_] := {brm[s], qrm[s], vrm[s]};

pcon[s_] := Module[{S},
S = First@If[StringMatchQ[s, "left"], feet, Reverse@feet];
<|0 -> BLFeet[S, {4, 5, 6, 1, 2, 3}][1]|>
];

vcon[s_] := Module[{},
<|-1 -> {q0[s]}, 3 -> {q3[s]}|>
];


(* ::Input::Initialization:: *)
arms[s_, p_] := Module[{t, w, parm},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];

(*t = BLIndices[t <> ".arm.ely", "", "n" \[Rule] {\[DoubleStruckQ], \[DoubleStruckV]}];
w = BLIndices[w <> ".arm.ely", "", "n" \[Rule] {\[DoubleStruckQ], \[DoubleStruckV]}];*)

t = BLIndices[t <> ".arm.shy", "", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}];
w = BLIndices[w <> ".arm.shy", "", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}];

parm = p;
parm[[t]] = -parm[[w]];

parm
];

legs[s_, p_] := Module[{b, t, w, a, h, pleg},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
pleg = p;

(* ankles *)
Do[
b = "float.base"|(i <> ".leg");
h = (i <> ".leg." ~~ __ ~~ j)|("r" <> j);

a = BLIndices[b, h, "n" -> {\[DoubleStruckQ]}];
pleg[[a[[-1]]]] = -Total@pleg[[a[[1;;-2]]]];

a = BLIndices[b, h, "n" -> {\[DoubleStruckV]}];
pleg[[a[[-1]]]] = -Total@pleg[[a[[1;;-2]]]];,
{i, {t, w}}, {j, {"x", "y"}}
];

pleg
];

knees[s_, A_] := Module[{t, w, a, xfix, pfix},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];

(* fix knees at q = 0,  x+ = \[Eta]p, associate with 0- *)
xfix = BLIndices[(w  <> ".leg.kn"), "", "n" -> \[DoubleStruckV]];
pfix = BLGetIndex[xfix, "m" -> s, "x" -> xrm[s]];
<|"k" ->  {pfix, xfix, Length@xfix}|>
];


(* ::Input::Initialization:: *)
blc[m_, cp_, C_] := Module[{m0, C0, E, i, j, k},
C0 = C;
(* add ankle constraint *)
E = BLbiped["blc", m, "\[Sigma]"];
If[!MissingQ[E] && Length@E == 3,
{i, j, k} = E;
(* ankle constraints *)
(* add slope to leg.aky joint angles *)
E = BL\[Sigma][m, C0[[All, 1;;nx]], C0];
C0[[All, i]] = C0[[All, i]]-E[[All, j]];
];

C0
];


(* ::Input::Initialization:: *)
qvInd[s_] := Module[{q, v},
{q, v} = Partition[BLIndices[BLGetBipedBase[], "p", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}], mm];
(* q is taken from \[Eta] = (PHC, VHC) *)
q = {q, Range[mm]};
(* v is taken from J[p], which is only px, py, pz dofs; see regime[...] *)
v = {v, Range[mm]};

{q, v}
];

Jind[s_] := qvInd[s][[1]]; (* \[LeftDoubleBracket]1\[RightDoubleBracket] b/c velocity indices start at 1 *)



(* ::Input::Initialization:: *)
cm[s_, A_] := Module[{t, w, q, v, a, \[Eta], \[Eta]p, \[Eta]v, p, cP, ceq, \[Theta]0T, C},
(* total \[Eta] constraints *)
p = A["np", s]+A["nv", s];
(* physical constraint indices in \[Eta] *)
t = Range[A["np", s]];
t = Join[t, t +p];
(* virtual constraint indices in \[Eta] *)
w = Range[A["np", s]+1, p];
w = Join[w, w +p];

(* indices in x0 *)
\[Eta]p = BLIndices[BLGetBipedBase[], "", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}];
(* indices in x0 *)
\[Eta]v = BLIndices[{q0[s], q3[s]}, "", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}];
\[Eta] = {"\[Eta]p" -> {\[Eta]p, t, 2p}, "\[Eta]v" -> {\[Eta]v, w, 2p}, "\[Sigma]" -> {BLIndices["leg.aky"], {2, 2}, mm}};

{q, v} = qvInd[s];
(* q is taken from \[Eta] = (PHC, VHC) *)
q = "q" -> Append[q, 2A["np", s]];
(* v is taken from J[p], which is only px, py, pz dofs; see regime[...] *)
v = "v" -> Append[v, mm];

\[Eta]p = {q, v, "f" -> blc};

(* polynomial scaling factors *)
\[Theta]0T = A["\[Theta]", s];

{t, w}  = stsw[s]; (* other leg shows controls affected by \[DoubleStruckC][s] *)

(* function specific parameters *)
a = <|"BLc" -> <|\[Eta]p|>, "BLc0T" -> <|"\[Theta]" -> \[Theta]0T|>, "blc" -> <|\[Eta]|>, "BLSummary" -> <|"P" -> pcon[w], "V" -> vcon[w]|>, "AtlasP" -> knees[s, A]|>;

(* c[p] \[Rule] c[p + some dependent vars] *)
cP = legs[s, arms[s, #]]&;

(* make second switching time T[2] = 2 T[1] *)
ceq = Function[{x, y}, BLTimeBasedceq[x, y]/. Slot[2]-> 2Slot[1]];

(* create parameters *)
C = BLContinuationParameters["base" -> brm[s], "q" -> qrm[s],  "v" -> vrm[s], "\[Alpha]" -> A["\[Alpha]", s, "\[Alpha]f"], "\[Mu]" -> n\[Mu], "T" -> dt, "c[p]" -> cP, "c[eq]" -> ceq, Association -> a];

<|s -> C|>
];

step[s_, A_] := Module[{f, st, sw, T},
(* s = left \[Rule] stance = right foot *)
(*f = {Append[feet, \[DoubleStruckC][-2]], Append[Reverse@feet, \[DoubleStruckC][-1]]};*)
f = {Append[Reverse@feet, \[DoubleStruckC][-2]], Append[feet, \[DoubleStruckC][-1]]};
{st, sw, T} = BLSide[s, f, 1];
BLxT[s, "ST" -> st, "SW" -> sw, "A" -> A, "\[Theta]T" -> T]
];

regime[s_] := Module[{P, V, B, S, \[Theta], n},
If[StringMatchQ[s, "left"], 
S = feet;
\[Theta] = {{\[DoubleStruckQ]["\[Theta]", 1], \[DoubleStruckV]["\[Theta]", 1], 0, \[DoubleStruckC][-2]}, {0, 0}};, 
(* else *)
S = Reverse@feet;
\[Theta] = {{\[DoubleStruckQ]["\[Theta]", 1], \[DoubleStruckV]["\[Theta]", 1], \[DoubleStruckC][-2], \[DoubleStruckC][-1]}, {0, 1}};
];

{P, V} = {pcon[s], vcon[s]};

BLRegime[s, "P" -> P, "V" -> V, "\[Theta]" -> \[Theta], "n\[Mu]" -> n\[Mu], "dt" -> dt, "S" -> S, "J[p]" -> Jind[s]]
];

viz[] := Module[{r, p, c, h},
r = {4, 5, 6};

p = #[[1]] <> "-poi-" <> ToString[#2[[1]]] -> \[DoubleStruckB][#[[1]], r, #[[2]]]&;
p = MapIndexed[p, poi];

c = Join[atlas[[All, 1]], Keys@p];
c = Select[c, StringTake[#, 1]== "r" &];

(* height of foot from ankle *)
h = GetFootData[][[1, 3]];

BLDontDraw[{BLGetBipedBase[]}];
(* hack *)
<|
"scale" -> Max[Norm /@ atlas[[All, RBDindex["f[xyz]"]]] /. \[DoubleStruckC][i_]-> 1],

"poi" -> <|p|>,

"lc" -> <|Thread[c -> LightGray]|>,

"surface" -> ({BLSide[#1, feet[[All, 1]], 1], {0, 0, h}}&)
|>
];

CreateModel[] := Module[{c},
(* robot model *)
atlas = CreateModelData[];

(* have arms pointing down, modifies atlas data *)
PutArmsDown[];

RBDNewModel[];
RBDLink["\[Theta]", Root, "m" -> 1, "S"-> "py"];
RBDLinks[atlas];

atlas = RBDLinks[];

(* draw limbs for leaf nodes *)
poi = POI[Complement[atlas[[All, 1]], atlas[[All, 2]]]];
poi = Join[poi, FootPOI[]];

(* project location of link relative to parent link and x COM *)
c = 2;;-1;
atlas[[c, RBDindex["f[x]"]]] = \[DoubleStruckC][-3] atlas[[c, RBDindex["f[x]"]]];
atlas[[c, RBDindex["c[x]"]]] = \[DoubleStruckC][-4] atlas[[c, RBDindex["c[x]"]]];

(* project location of y COM using \[DoubleStruckC][-4] *)
c = StringFreeQ[atlas[[#, 1]],"\[Theta]"|("back"~~__~~("y"|"z"))]&;
c = Select[Range@Length@atlas, c];
atlas[[c, RBDindex["c[y]"]]] = \[DoubleStruckC][-4] atlas[[c, RBDindex["c[y]"]]];

(* project location of y COM, keep @ zero for period-1 gaits *)
(* these are links without a left/right pair *)
c = StringContainsQ[atlas[[#, 1]],("back"~~__~~("y"|"z"))]&;
c = Select[Range@Length@atlas, c];
atlas[[c, RBDindex["c[y]"]]] = 0;

RBDCreateModel["L" -> atlas, "g" -> g, "spat" -> False];
];


(* ::Input::Initialization:: *)
Options[AtlasSurface] = {"m" :> BLbiped["m[0]"]};
AtlasSurface[\[CurlyPhi]_, d_, OptionsPattern[]] := Module[{m, n, \[Sigma], x, c, ax, pos},
m = OptionValue["m"];
ax = mm + Lookup[d, "axes", BipedalLocomotion`Private`axes];
n = Lookup[d, "\[Sigma]", Automatic];

(* compute slope *)
c = If[AssociationQ[\[CurlyPhi]],  \[CurlyPhi]["c[t]"][0], \[CurlyPhi]];
c = devec[c, nc];
x = c[[All, 1;;nx]];

\[Sigma] = BLbiped["\[Sigma]", m][x, c];
\[Sigma] = \[Sigma][[1;;mm]];

pos = First@BipedalLocomotion`Private`LinkPositions[x, c, "b" -> d];
pos = pos /@ {"l.leg.akx-poi-7", "l.leg.akx-poi-8", "l.leg.akx-poi-9"};

If[Length[ax] == 2,
If[n === Automatic, n = First@Complement[Range[mm+1, nm],  ax]-mm;];
\[Sigma] = \[Sigma][[n]];
{BipedalLocomotion`Private`sc, InfiniteLine[{0, 0}, RotationMatrix[\[Sigma]].{1, 0}]},
(* else biped is 3D *)
If[n === Automatic, n = ax[[1;;2]];];
n = n - mm;
x = IdentityMatrix[mm][[n]];
\[Sigma] = \[Sigma][[n]];

n[[1]] = RotationMatrix[-\[Sigma][[2]], x[[2]]].x[[1]];
n[[2]] = RotationMatrix[-\[Sigma][[2]], x[[2]]].x[[2]];
{BipedalLocomotion`Private`sc, InfinitePlane[pos]}
]
];


(* ::Input::Initialization:: *)
AtlasMeshOptions[] := Module[{f, info, joints, links, A},
f = Function[x, StringRiffle[List@@x, "-"], Listable];

(* get all joint names *)
A = f[RBDGetValue[1, nq, "n" -> True]];
A = Association@Thread[A -> <|"mesh" -> <||>|>];

(* pair joints (\[DoubleStruckQ][name, -1]) with links *)
info = ParseLink@GetLinkNames[];
joints = f[RBDGetDOF[\[DoubleStruckQ][info[[All, 3]], -1]]];
links = info[[All, 1, 1]];

Do[
A[joints[[i]], "mesh", "file"] = (*"atlas/meshes/" <> *)links[[i]] <> ".dae";,
{i, 1, Length@joints}
];

A[Root] = <|"loader" -> "Atlas/index.js"|>;

A
];


(* ::Input::Initialization:: *)
AtlasP[cp_, opts:OptionsPattern[]] := AtlasP[BLbiped["m[0]"], cp, opts]["R"];

AtlasP[mp_String, cp_, opts:OptionsPattern[]] := Module[{R, m, C, X, M, I, FB, i, j, k, T, \[Sigma]},
m = mp;
M = BLP[m, cp, opts, BLMap -> {"DT" -> {0, -2}}];
{R, X, C} = Values@M[[{"R", "x+", "c"}]];

(* post-impact knee constraints *)
{i, j} = BLbiped["AtlasP", m, "k"][[1;;2]];
R[[All, i]] = X[[2, All, j]];

T = C[[1, All, -1;;-1]]-2C[[1, All, -2;;-2]];

I = C[[1, All, BLbiped["c", m, "\[Mu]"]]];

M["R"] = MapThread[Join, {R, I, T}];

M
];


(* ::Input::Initialization:: *)
Atlas[n_:0] := Module[{A, c, x, l, r},
(* model *)
CreateModel[];

(* constraints *)
x = {BLValues["l.", "x"|"z"], BLValues["r.", "x"|"z"]}\[Transpose];
x = Join[{#, #}& /@ BLValues["back.", "x"|"z"], x];
x = Join[{#, #}& /@ BLValues["float.base", "rx"|"rz"|"py"], x];
A = BLA[x];

x = BLIndices["float.base", "py", "n" -> \[DoubleStruckV]];
A[[x,x]] = -IdentityMatrix[Length@x];

(* regimes *)
l = regime["left"];
r = regime["right"];
c = Join[l ,r];

(* map pre-impact to pre-impact *)
l = step["left", A];
r = step["right", A];
x = Join[l, r];

A = BLCreateBiped["Atlas", c, x, viz[], feet, <|"A" -> A|>];

c = Join[cm["left", A], cm["right", A]];
BLCreateContinuationParameters["right", c];

(* don't expand certain constraints *)
c = {_, _, ((\[DoubleStruckB]')|\[DoubleStruckB])[__], __};
c = Flatten@Position[RigidBodyDynamics`Private`con, c];
RigidBodyDynamics`Private`con[[c, -2]] = False;
RBDSpatialFunctions[];

BLCompileBiped[n]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
