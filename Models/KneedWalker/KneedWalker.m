(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`KneedWalker`", {"GlobalVariables`", "RigidBodyDynamics`", "BipedalLocomotion`", "BipedalLocomotion`Model`", "HybridDynamics`"}]

KneedWalker::usage = "";
KneedWalkerP::usage = "";

Begin["`Private`"]


(* ::Input::Initialization:: *)
(* parameters *)
mod1[] := Module[{},
(* from parameters in [1] *)
a1 = 0.375;
b1 = 0.125;
a2 = 0.175;
b2 = 0.325;
mh = 0.5;
mt = 0.5;
ms = 0.05;

ls = a1 + b1;
lt = a2 + b2;
L = ls + lt;
];

mod2[] := Module[{},
(* from the URDF in [2] *)
a1 = 0.25;
b1 = a1;
a2 = a1;
b2 = a1;
mh = 10;
mt = 2.5;
ms = 2.5;

ls = a1 + b1;
lt = a2 + b2;
L = ls + lt;
];

mod3[] := Module[{ush, uth, bs, bls, blt},
(* from parameters in [3] *)
mh = 1;
L = 1;
ush = 0.05;
uth = 1;
bs = 0.5;
bls = 0.75;
blt = 0.5;

ms = ush mh;
mt = uth  mh;
ls = bs L;
lt = (1-bs)L;
a1 = bls bs L;
b1 = (1-bls)bs L;
a2 = blt (1-bs)L;
b2 = (1-blt)(1-bs)L;
];

g = {0, 9.81, 0};

(* points of interest *)
knee = {0, -lt, 0};
lk = {"left thigh", knee};
rk = {"right thigh", knee};

foot = {0, -ls, 0};
lf = {"left shank", foot};
rf = {"right shank", foot};
feet = {lf, rf};

(* switching times & controls *)
n\[Mu] = 0;
dt = {0, -2, -1};


(* ::Input::Initialization:: *)
con[f_, s_String, A___] := f[s, A, If[StringContainsQ[s, "2"], 2, 3]];
stsw[s_, a_:"left", b_:"right"] := If[StringContainsQ[s, "left"],  a, b];


(* ::Input::Initialization:: *)
pcon[s_, 2] := stsw[s,  <|0 -> {lf, "shank"}|>, <|0 -> {rf, "shank"}|>];
pcon[s_, 3] := stsw[s, <|0 -> {lf, "left shank"}|>, <|0 -> {rf, "right shank"}|>];


(* ::Input::Initialization:: *)
icon[s_, 2] := stsw[s,  <|0 -> {lf, "shank"}|>, <|0 -> {rf, "shank"}|>];
icon[s_, 3] := stsw[s, <|0 -> {lf, "shank"}|>, <|0 -> {rf, "shank"}|>];


(* ::Input::Initialization:: *)
regime[s_, 2] := Module[{P, S, I, \[Theta], n, Jind},
\[Theta] = {{\[DoubleStruckQ]["\[Theta]", 1], \[DoubleStruckV]["\[Theta]", 1], \[DoubleStruckC][-2], \[DoubleStruckC][-1]}, {0, 1}};
S = stsw[s,  feet, Reverse@feet];
P = con[pcon, s];
I = con[icon, s];
Jind = BLIndices[{"hip", "shank"}];
BLRegime[s, "P" -> P, "I" -> I, "\[Theta]" -> \[Theta], "n\[Mu]" -> n\[Mu], "dt" -> dt, "S" -> S, "J[p]" -> {Jind, Range@Length@Jind}]
];

regime[s_, 3] := Module[{P, S, I, \[Theta], n, Jind},
\[Theta] = {{\[DoubleStruckQ]["\[Theta]", 1], \[DoubleStruckV]["\[Theta]", 1], 0, \[DoubleStruckC][-2]}, {0, 0}};
S = stsw[s,  feet, Reverse@feet];
P = con[pcon, s];
I = con[icon, s];
Jind = BLIndices[{"hip", stsw[s] <> " shank"}];
BLRegime[s, "P" -> P, "I" -> I, "\[Theta]" -> \[Theta], "n\[Mu]" -> n\[Mu], "dt" -> dt, "S" -> S, "J[p]" -> {Jind, Range@Length@Jind}]
];


(* ::Input::Initialization:: *)
cm[s_, A_, 2] := Module[{q, v, a, n, \[Theta]0T, C},
(* BLc indices *)
n = mm -1; (* 2D *)
{q, v} = Partition[BLIndices[BLGetBipedBase[], "p", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}], n];
q = "q" -> {q, Range@Length@q, 2A["np", s]};
v = "v" -> {v, Range@Length@v, A["np", s]};

(* polynomial scaling factors *)
\[Theta]0T = A["\[Theta]", s];

(* 3 \[Rule] knee pre-impact index in X *)
n = {3, BLIndices[stsw[s] <>  " shank"]}; 

(* function specific parameters *)
a = <|"BLc" -> <|q, v|>, "BLc0T" -> <|"\[Theta]" -> \[Theta]0T|>, "BLSummary" -> <|"P" -> pcon[s]|>, "KneedWalkerP" -> n|>;

(* create parameters *)
C = BLContinuationParameters["q" -> "shank", "v" -> "shank", "\[Mu]" -> n\[Mu], "T" -> dt, Association -> a];

<|s -> C|>
];

cm[s_, A_, 3] := Module[{q, v, a, n, \[Theta]0T, C},
(* this function might need more work;  knee and heel strike switching *)
(* times might have to be swapped and need to figure out when knee *)
(* constraint has to be applied.  this only affects beginning of swing BLc *)
(* and map KneedWalkerP *)

(* BLc indices *)
n = mm -1; (* 2D *)
{q, v} = Partition[BLIndices[BLGetBipedBase[], "p", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}], n];

q = "q" -> {q, Range@Length@q, 2A["np", s]};
v = "v" -> {v, Range@Length@v, A["np", s]};
(* need to keep v and J[p] indices in sync *)

(* polynomial scaling factors *)
\[Theta]0T = A["\[Theta]", s];

(* 4 \[Rule] knee pre-impact (including switching time derivative) *)
n = {4, BLIndices[stsw[s, "right", "left"] <>  " shank"]}; 
(* function specific parameters *)
a = <|"BLc" -> <|q, v|>, "BLc0T" -> <|"\[Theta]" -> \[Theta]0T|>, "BLSummary" -> <|"P" -> pcon[s]|>, "KneedWalkerP" -> n|>;

C = BLContinuationParameters["q" -> "shank", "v" -> "shank", "\[Mu]" -> n\[Mu], "T" -> dt, Association -> a];

<|s -> C|>
];


(* ::Input::Initialization:: *)
viz[] := Module[{r},
r = {4, 5, 6};
BLDontDraw[{"hip"}];
BLRadius[0.09];
BLWidth[0.06];

<|
"axes" -> {1, 2},

"scale" -> L,

"poi" -> <|"left foot" -> \[DoubleStruckB]["left shank", r, foot], "right foot" -> \[DoubleStruckB]["right shank", r, foot]|>,

(* link associated with outbound/child joint *)
"lc" -> <|"right shank" -> LightGray, "right foot" -> LightGray|>
|>
];

CreateModel[\[Theta]_:True] := Module[{com, c},
RBDNewModel[];
If[\[Theta], RBDLink["\[Theta]", Root, "m" -> 1, "S"-> "pz"];];

RBDLink["hip", Root, "m" -> mh, "S"-> "xy"];

com = {0, -b2, 0};
c = {"left thigh", "right thigh"};
RBDLink[c, "hip", "m" -> mt, "com" -> com, "S"-> "rz"];

com = {0, -b1, 0};
c = {{"left shank", "right shank"}, c};
RBDLink[c[[1]], c[[2]], "m" -> ms, "com" -> com, "S"-> "rz", "loc" -> {0, -lt, 0}];

RBDCreateModel["g" -> g];
];


(* ::Input::Initialization:: *)
KneedWalkerP[cp_, opts:OptionsPattern[]] := KneedWalkerP[BLbiped["m[0]"], cp, opts]["R"];

KneedWalkerP[mp_String, cp_, opts:OptionsPattern[]] := Module[{R, C, X, M, I, T, i, j},
{i, j} = BLbiped["KneedWalkerP", mp];

M = BLP[mp, cp, opts];
{R, X, C} = Values@M[[{"R", "x-", "c"}]];

(* test to see that right number of impacts occurred *)
If[Length@X != 4 || Length@C != 3, 
(*Print[{"x|c", Length@X, Length@C, cp}];*)
Throw[$Failed]
];

(* pre-impact constraint prior to knee strike *)
T = X[[i, All, j]];
T[[1]] = BLAngle@T[[1]];

(* fix controls *)
I = C[[1, All, BLbiped["c", mp, "\[Mu]"]]];

X = Join[R[[1]], I[[1]], T[[1]]];
M["R"] = If[Length@R >= 2, {X, Join[R[[2]], I[[2]], T[[2]]]}, {X}];

M
];


(* ::Input::Initialization:: *)
ks[m_, x_?VectorQ] := x[[7]];


(* ::Input::Initialization:: *)
KneedWalker[n_:0, f_:mod2] := Module[{A, A1, A2, C, X, L1, L2, R1, R2},
f[];
CreateModel[];

(* coordinate flip *)
A1 = IdentityMatrix[nx];
A2 = BLA[];

(* create dynamic regimes *)
L1 = con[regime, "left-3"];
L2 = con[regime, "left-2"];
R1 = con[regime, "right-3"];
R2 = con[regime, "right-2"];
C = Join[L1, L2, R1, R2];

(* create jumps given state of biped at transition at t- (pre-impact) *)
(*L1 = BLxT["left-3", "A" \[Rule] A1, "\[Theta]T" \[Rule] \[DoubleStruckC][-2]];
L2 = BLxT["left-2", "ST" \[Rule] rf, "SW" \[Rule] lf, "A" \[Rule] A2, "\[Theta]T" \[Rule] \[DoubleStruckC][-1]];
R1 = BLxT["right-3", "A" \[Rule] A1, "\[Theta]T" \[Rule] \[DoubleStruckC][-2]];
R2 = BLxT["right-2", "ST" \[Rule] lf, "SW" \[Rule] rf, "A" \[Rule] A2, "\[Theta]T" \[Rule] \[DoubleStruckC][-1]];*)
(* L1/R1 is flipped biped of R2/L2 *)

(* original *)
(*L1 = BLxT["left-3", "ST" \[Rule] rf, "SW" \[Rule] lf, "A" \[Rule] A2, "\[Theta]T" \[Rule] \[DoubleStruckC][-2]];
L2 = BLxT["left-2", "A" \[Rule] A1, "\[Theta]T" \[Rule] \[DoubleStruckC][-1]];
R1 = BLxT["right-3", "ST" \[Rule] lf, "SW" \[Rule] rf, "A" \[Rule] A2, "\[Theta]T" \[Rule] \[DoubleStruckC][-2]];
R2 = BLxT["right-2", "A" \[Rule] A1, "\[Theta]T" \[Rule] \[DoubleStruckC][-1]];
X = Join[L1, L2, R1, R2];*)

L1 = BLxT["left-3", "ST" -> rf, "SW" -> lf, "A" -> A2, "\[Theta]T" -> \[DoubleStruckC][-2]];
L2 = BLxT["left-2", "A" -> A1, "\[Theta]T" -> \[DoubleStruckC][-1]];
R1 = BLxT["right-3", "ST" -> lf, "SW" -> rf, "A" -> A2, "\[Theta]T" -> \[DoubleStruckC][-2]];
R2 = BLxT["right-2", "A" -> A1, "\[Theta]T" -> \[DoubleStruckC][-1]];
X = Join[L1, L2, R1, R2];

(* TODO: <|"A" \[Rule] A2|> is not legit for this model, need A1 and A2 *)
A = BLCreateBiped["Kneed Walker", C, X, viz[], feet, <|"A" -> A2|>];
L1 = con[cm, "left-3", A];
L2 = con[cm, "left-2", A];
R1 = con[cm, "right-3", A];
R2 = con[cm, "right-2", A];
C = Join[L1, L2, R1, R2];
BLCreateContinuationParameters["right-2", C];

X =  <|"right-2" -> ("left-3"&), "left-3" -> ("left-2"&), "left-2" -> ("right-3"&), "right-3" -> ("right-2"&)|>;

(*AddSwitchingEvent[ks[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]]] \[Equal] 0, "a" \[Rule] {"RemoveEvent"}];*)
BLCompileBiped[n, "m" ->  X]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
