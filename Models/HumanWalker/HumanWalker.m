(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`HumanWalker`", {"GlobalVariables`", "RigidBodyDynamics`", "BipedalLocomotion`", "BipedalLocomotion`Model`", "HybridDynamics`"}]

HumanWalker::usage = "";

Begin["`Private`"]


(* ::Input::Initialization:: *)
(* parameters *)
g = {0, 9.81, 0};


(* ::Input::Initialization:: *)
(* # of control/design parameters *)
n\[Mu] = 0;


(* ::Input::Initialization:: *)
(* pre-impact stance x[0-]/c- *)
stsw[s_, f_:{"Left", "Right"}] := If[StringMatchQ[s, "Left", IgnoreCase->True], f, Reverse@f];


(* ::Input::Initialization:: *)
regopt[s_] := Module[{S},
S = stsw[s, feet];

{"P" -> <|0 -> BLFeet[First@S, {4, 5}][1]|>, "S" -> S, "n\[Mu]" -> n\[Mu]}
];


(* ::Input::Initialization:: *)
qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
(w <>" Foot")
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
(w <>" Foot")
];


(* ::Input::Initialization:: *)
ankles[s_, N_] := Module[{t, w, n, r},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)

(* post-impact map x+ = \[Eta]p, get ankle indices *)
n = Join[BLIndices[w <> " Foot"]];
n = Join[(*n, *)nq+n];

r = {mm};
r = Join[(*r, *)mm+r];

{n, r, N}
];

legs[s_, p_] := Module[{b, t, w, a, k, h, pleg},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
pleg = p;

(* base *)
b = BLIndices[BLGetBipedBase[], "rz"];

(* base equals hip + ankle *)
a = BLIndices[t <> " Foot"];
k = BLIndices[t <> " Leg"];
h = BLIndices[t <> " Thigh"];
pleg[[b]] = -pleg[[h]]-pleg[[k]]-pleg[[a]];

(* swing equals opposite of stance *)
a = BLIndices[w <> " Foot"];
k = BLIndices[w <> " Leg"];
h = BLIndices[w <> " Thigh"];
pleg[[a]] = -pleg[[k]]-pleg[[h]]-pleg[[b]];

pleg
];

blc[m_, cp_, C_] := Module[{m0, C0, E, i, j, k},
C0 = C;
(* add ankle constraint *)
E = BLbiped["blc", m, "q"];
If[!MissingQ[E] && Length@E == 3,
{i, j, k} = E;
m0 = BLbiped["m", m][C0[[All, 1;;nx]], C0];
E = devec[BLbiped["\[Eta]p", m0][C0[[All, 1;;nx]], C0], k];
C0[[All, i]] = -E[[All, j]];
];

C0
];


(* ::Input::Initialization:: *)
cm[s_, A_] := Module[{q, v, a, n, \[Theta]0T, C, cP, t, w},
(* BLc indices *)

(* solve for constraints w/ linear components *)
q = BLIndices[BLGetBipedBase[], "p"];
v = BLIndices[BLGetBipedBase[], "p", "n" -> \[DoubleStruckV]];

(*v = BLIndices[BLGetBipedBase[], "", "n" \[Rule] \[DoubleStruckV]];*)

(* second arg is indices in constraint Jacobian *)
q = "q" -> {q, Range@Length@q, 2A["np", s]};
v = "v" -> {v, Range@Length@v, A["np", s]};

(* polynomial scaling factors *)
\[Theta]0T = A["\[Theta]", s];

{t, w}  = stsw[s]; (* other leg shows controls affected by \[DoubleStruckC][s] *)

(* function specific parameters *)
a = <|"BLc" -> <|q, v(*, "f" \[Rule] blc*)|>, "BLc0T" -> <|"\[Theta]" -> \[Theta]0T|>, "BLSummary" -> <|"P" -> First@regopt[w]|>|>;

(* c[p] \[Rule] c[p + some dependent vars] *)
cP = legs[s, #]&;

(* create parameters *)
C = BLContinuationParameters[Association -> a, "\[Mu]" -> n\[Mu]];

<|s -> C|>
];

viz[] := Module[{r, c, L, poi},
r = {4, 5, 6};
BLDontDraw[{"Pelvis"}];
BLRadius[0.01];
BLWidth[0.01];

(* reflection about z axis *)
L = {1, 1, -1};

poi = <||>;

poi["Head"] = \[DoubleStruckB]["Head & Neck", r,  POI["CJC to HV"]];

poi["Left Foot"] = \[DoubleStruckB]["Left Leg", r, L JC["KJC to AJC"]];
poi["Right Foot"] = \[DoubleStruckB]["Right Leg", r, JC["KJC to AJC"]];

(*poi["Left Toe"] = \[DoubleStruckB]["Left Foot", r, L POI["AJC to TT2"]];
poi["Right Toe"] = \[DoubleStruckB]["Right Foot", r, POI["AJC to TT2"]];*)

poi["Left Finger"] = \[DoubleStruckB]["Left Hand", r,  L POI["WJC to FT3"]];
poi["Right Finger"] = \[DoubleStruckB]["Right Hand", r,  POI["WJC to FT3"]];

(* scaled length *)
L = Total@KeySelect[SL, StringFreeQ[#, "Alt."]&];

c = Join[Values@WM[[All, 1]], Keys@poi];
c = Select[c, StringContainsQ[#, "Right"] &];

<|
"axes" -> {1, 2},

"scale" -> L,

"poi" -> poi,

"lc" -> <|Thread[c -> LightGray]|>
|>
];

CreateModel[] := Module[{com, c},
RBDNewModel[];
RBDLink["\[Theta]", Root, "m" -> 1, "S"-> "pz"];
RBDLinks[Values@WM];
RBDCreateModel["g" -> g];
];


(* ::Input::Initialization:: *)
HumanWalker[n_:0] := Module[{A, C, X, J, l, r, draw, L, R},
CreateModel[];

(* coordinate flip *)
A = BLA[];

(* create dynamic regimes *)
L = BLRegime["left", regopt["Left"]];
R = BLRegime["right",regopt["Right"]];
C = Join[L, R];

(* create jumps given state of biped at transition at t- (pre-impact) *)
l = feet[[1]];
r = feet[[2]];

L = BLxT["left", "ST" -> r, "SW" -> l, "A" -> A];
R = BLxT["right", "ST" -> l, "SW" -> r, "A" -> A];
X = Join[L, R];

A = BLCreateBiped["Human Walker", C, X, viz[], feet, <|"A" -> A|>];
C = Join[cm["left", A], cm["right", A]];
BLCreateContinuationParameters["right", C];

(* don't expand certain constraints *)
C = {_, _, ((\[DoubleStruckB]')|\[DoubleStruckB])[__], __};
C = Flatten@Position[RigidBodyDynamics`Private`con, C];
RigidBodyDynamics`Private`con[[C, -2]] = False;
RBDSpatialFunctions[];

BLCompileBiped[n]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
