(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`Rabbit`", {"GlobalVariables`", "RigidBodyDynamics`", "BipedalLocomotion`", "BipedalLocomotion`Model`"}]

Begin["`Private`"]


(* ::Input::Initialization:: *)
VHC[0] := Module[{},
(* continuation matrix *)
P = <|"left" -> {}, "right" -> {}|>;

vcon[s_] := {};

qrm[s_] := "none";

vrm[s_] := "none";

RabbitP[m_String, cp_, opts:OptionsPattern[]] := BLP[m, cp, opts];
];


(* ::Input::Initialization:: *)
VHC[1] := Module[{},
(* continuation matrix *)
P = <|"left" -> DiagonalMatrix[{1, 0, 1, 1}], "right" -> DiagonalMatrix[{0, 1, 1, 1}]|>;

vcon[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];
(* virtual constraints *)
<|3 -> {{"fem"| "tib"}}|>
];

qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
"none"
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
"none"
];

RabbitP[m_String, cp_, opts:OptionsPattern[]] := Module[{i, j, n, M},
M = BLP[m, cp, opts];
n = Length@BLbiped["c", m, "x"]/2;

i = {2};
i = Join[i, i + n];
j = {5};
j = Join[j, j+nq];
(* next pre-impact state *)
M[["R", All, i]] = M[["x-", -1, All, j]];

i = {4};
i = Join[i, i + n];
j = {7};
j = Join[j, j+nq];
(* first post-impact state *)
M[["R", All, i]] = M[["x+", 2, All, j]];

i = {5};
i = Join[i, i + n];
j = {8};
j = Join[j, j+nq];
(* initial pre-impact state *)
M[["R", All, i]] = M[["x-", 1, All, j]];

M
];
];


(* ::Input::Initialization:: *)
VHC[2] := Module[{},
(* continuation matrix *)
P = <|"left" -> DiagonalMatrix[{1, 0, 1, 1}], "right" -> DiagonalMatrix[{0, 1, 1, 1}]|>;

vcon[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];
(* virtual constraints *)
<|3 -> {{"fem"| "tib"}}|>
];

qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
"none"
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
"none"
];

RabbitP[m_String, cp_, opts:OptionsPattern[]] := Module[{i, j, n, M},
M = BLP[m, cp, opts];
n = Length@BLbiped["c", m, "x"]/2;

(* zero next pre-impact state *)
i = {2, 4, 5};
i = Join[i, i + n];
j = {5, 7, 8};
j = Join[j, j+nq];
M[["R", All, i]] = M[["x-", -1, All, j]];

M
];
];


(* ::Input::Initialization:: *)
VHC[3] := Module[{},
(* continuation matrix *)
P = <|"left" -> {}, "right" -> {}|>;

vcon[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];
(* virtual constraints *)
<|-1 -> {{t  <> " tib"}}, 3 -> {{(*(w <> " fem")|*) (w  <> " tib")}}|>
];

qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
"tib"
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
t <> " tib"
];

RabbitP[m_String, cp_, opts:OptionsPattern[]] := Module[{i, j, n, M},
M = BLP[m, cp, opts];
n = Length@BLbiped["x[p]"]/2;
i = {7};
j = {nq+7};
M[["R", All, i]] = M[["x+", 2, All, j]];
M
];
];


(* ::Input::Initialization:: *)
VHC[4] := Module[{},
(* continuation matrix *)
P = <|"left" -> {}, "right" -> {}|>;

vcon[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];
(* virtual constraints *)
<|3 -> {{"tib"}}|>
];

qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
"none"
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
"none"
];

RabbitP[m_String, cp_, opts:OptionsPattern[]] := Module[{i, j, n, M},
M = BLP[m, cp, opts];
n = Length@BLbiped["c", m, "x"]/2;
i = {4,5};
i = Join[i, i + n];
j = {7, 8};
j = Join[j, j+nq];
M[["R", All, i]] = M[["x-", -1, All, j]];
M
];
];


(* ::Input::Initialization:: *)
VHC[5] := Module[{},
(* continuation matrix *)
P = <|"left" -> {}, "right" -> {}|>;

vcon[s_] := Module[{t, w},
(* post-impact stance/swing x[0+]/c+ *)
{t, w} = stsw[s];
(* virtual constraints *)
<|5 -> {{"fem"| "tib"}}|>
];

qrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following configurations *)
"none"
];

vrm[s_] := Module[{t, w},
(* pre-impact stance/swing x[0-]/c- *)
{t, w} = stsw[s];
(* remove following velocities *)
"none"
];

RabbitP[m_String, cp_, opts:OptionsPattern[]] := Module[{i, j, n, M},
M = BLP[m, cp, opts];
n = Length@BLbiped["c", m, "x"]/2;
i = {2, 3, 4, 5};
i = Join[i, i + n];
j = {5, 6, 7, 8};
j = Join[j, j+nq];
M[["R", All, i]] = M[["x-", -1, All, j]];
M
];
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
